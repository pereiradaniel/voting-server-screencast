=TUTORIAL NOTES=

18/Nov/2016

  LOOK-UP:
    - Actions and Reducers

    Actions:
      Actions are payloads of information that send data from your application to your store. They are the only source of information for the store. You send them to the store using store.dispatch().

      Actions are plain JavaScript objects. Actions must have a type property that indicates the type of action being performed. Types should typically be defined as string constants. Once your app is large enough, you may want to move them into a separate module.

      ref: http://devdocs.io/redux/basics/actions

    Reducers:
      Actions describe the fact that something happened, but don't specify how the application's state changes in response. This is the job of a reducer.

      ref: http://devdocs.io/redux/basics/reducers

    - export default function

      export default:
        If we want to export a single value or to have a fallback value for our module, we could use a default export:

        ref: http://devdocs.io/javascript/statements/export

    - switch and case

      switch:
        The switch statement evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.

        ref: http://devdocs.io/javascript/statements/switch

    - undefined

      undefined:
        The global undefined property represents the primitive value undefined. It is one of JavaScript's primitive types.

        undefined is a property of the global object, i.e. it is a variable in global scope. The initial value of undefined is the primitive value undefined.

        In modern browsers (JavaScript 1.8.5 / Firefox 4+), undefined is a non-configurable, non-writable property per the ECMAScript 5 specification. Even when this is not the case, avoid overriding it.

        A variable that has not been assigned a value is of type undefined. A method or statement also returns undefined if the variable that is being evaluated does not have an assigned value. A function returns undefined if a value was not returned.

        ref: http://devdocs.io/javascript/global_objects/undefined

    - const

      const:
        Constants are block-scoped, much like variables defined using the let statement. The value of a constant cannot change through re-assignment, and it can't be redeclared.

        This declaration creates a constant that can be either global or local to the function in which it is declared. An initializer for a constant is required; that is, you must specify its value in the same statement in which it's declared (which makes sense, given that it can't be changed later).

        The const declaration creates a read-only reference to a value. It does not mean the value it holds is immutable, just that the variable identifier cannot be reassigned. For instance, in case the content is an object, this means the object itself can still be altered.

        ref: http://devdocs.io/javascript/statements/const


19/Nov/2016

  LOOK-UP:
    - Redux store

      Store:
        A store holds the whole state tree of your application.

        The only way to change the state inside it is to dispatch an action on it.

        A store is not a class. It's just an object with a few methods on it.

        To create it, pass your root reducing function to createStore.

        ref: http://devdocs.io/redux/api/store


    - dispatch(action)

      dispatch(action):
        Dispatches an action. This is the only way to trigger a state change.

        The store's reducing function will be called with the current getState() result and the given action synchronously. Its return value will be considered the next state. It will be returned from getState() from now on, and the change listeners will immediately be notified.

        ref: http://devdocs.io/redux/api/store#dispatch


    - fromJS (immutable-js):
        Deeply converts plain JS objects and arrays to Immutable Maps and Lists.

        ref: https://facebook.github.io/immutable-js/docs/#/fromJS


    - Git push.default

      git push origin:
        Without additional configuration, pushes the current branch to the configured upstream (remote.origin.merge configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise.

        The default behavior of this command when no <refspec> is given can be configured by setting the push option of the remote, or the push.default configuration variable.

        For example, to default to pushing only the current branch to origin use git config remote.origin.push HEAD. Any valid <refspec> (like the ones in the examples below) can be configured as the default for git push origin.

        ref: http://devdocs.io/git/git-push


    - socket.io
      - 'Server' from socket.io
          
        Server():
          Creates a new Server. Works with and without new.

          ref: http://devdocs.io/socketio/server-api#server


        Server#attach:
          Server#attach(port:Number, opts:Object):Server

          Attaches the Server to an engine.io instance that is bound to port with the given opts (optionally).

          ref: http://devdocs.io/socketio/server-api#server-attach-srv-http-server-opts-object-server


      - babel-node (from babel-cli package)

        babel-node:
          Not meant for production use
          
          You should not be using babel-node in production. It is unnecessarily heavy, with high memory usage due to the cache being stored in memory. You will also always experience a startup performance penalty as the entire app needs to be compiled on the fly.

          Check out the example Node.js server with Babel for an idea of how to use Babel in a production deployment.

          ref: https://babeljs.io/docs/usage/cli/

      - WebSockets

        Websocket:
          This is an experimental technology
          
          Because this technology's specification has not stabilized, check the compatibility table for usage in various browsers. Also note that the syntax and behavior of an experimental technology is subject to change in future versions of browsers as the specification changes.

          The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection.

          ref: http://devdocs.io/dom/websocket


      - fallback mechanisms

        'Fallback mechanism':
          Socket.io has fallback mechanisms for clients that don't support WebSockets.

          ref: http://blog.caplin.com/2010/03/02/why-we-dont-need-html5-websocket/


21/Nov/2016

  - Emitting a Socket.io event
    http://socket.io/docs/server-api/#server#emit

  - Subscribe to Redux store

  - Listening for connections on Socket.io

  - .toJS()